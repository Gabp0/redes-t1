#include "chat_screen.h"
#include <ncurses.h>
#include <locale.h>
#include <string.h>

WINDOW *create_newwin(int height, int width, int starty, int startx)
{
    WINDOW *local_win = newwin(height, width, starty, startx);
    box(local_win, 0, 0);
    wrefresh(local_win);

    return (local_win);
}

ChatScreen::ChatScreen()
{
    setlocale(LC_ALL, "");
    initscr();

    cbreak();             // Immediate key input
    nonl();               // Get return key
    timeout(0);           // Non-blocking input
    keypad(stdscr, true); // Fix keypad
    noecho();             // No automatic printing
    curs_set(0);          // Hide real cursor
    intrflush(stdscr, 0); // Avoid potential graphical issues
    leaveok(stdscr, 1);   // Don't care where cursor is left

    this->linebuffer.ln = NULL;
    this->linebuffer.length = 0;
    this->linebuffer.capacity = 0;
    this->linebuffer.cursor = 0;
    this->linebuffer.last_rendered = 0;

    getmaxyx(stdscr, this->row, this->col);
    this->lines_read = 0;

    refresh();
    this->chat_box = create_newwin(5, this->col, this->row - 6, 0);
    wmove(this->chat_box, 1, 1);
    wrefresh(this->chat_box);
}

ChatScreen::~ChatScreen()
{
    endwin();
    delete &linebuffer;
}

void ChatScreen::render_line(struct input_line *buf)
{
    int i = 0;
    for (; i < this->linebuffer.length; i++)
    {
        chtype c = this->linebuffer.ln[i];
        if (i == this->linebuffer.cursor)
        {
            c |= A_REVERSE;
        }
        addch(c);
    }
    if (this->linebuffer.cursor == this->linebuffer.length)
    {
        addch(' ' | A_REVERSE);
        i++;
    }
    int rendered = i;
    // Erase previously rendered characters
    for (; i < this->linebuffer.last_rendered; i++)
    {
        addch(' ');
    }
    this->linebuffer.last_rendered = rendered;
}

int ChatScreen::retrieve_content(char *target, int max_len)
{
    int len = this->linebuffer.length < (max_len - 1) ? this->linebuffer.length : (max_len - 1);
    memcpy(target, this->linebuffer.ln, len);
    target[len] = '\0';
    this->linebuffer.cursor = 0;
    this->linebuffer.length = 0;
    return len + 1;
}

void ChatScreen::add_char(char ch)
{
    // Ensure enough space for new character
    // if (this->linebuffer.length == this->linebuffer.capacity)
    // {
    //     int ncap = this->linebuffer.capacity + 128;
    //     char *nln = (char *)realloc(this->linebuffer.ln, ncap);
    //     if (!nln)
    //     {
    //         // Out of memory!
    //         return;
    //     }
    //     this->linebuffer.ln = nln;
    //     this->linebuffer.capacity = ncap;
    // }

    // Add new character
    memmove(
        &this->linebuffer.ln[this->linebuffer.cursor + 1],
        &this->linebuffer.ln[this->linebuffer.cursor],
        this->linebuffer.length - this->linebuffer.cursor);
    this->linebuffer.ln[this->linebuffer.cursor] = ch;
    ++this->linebuffer.cursor;
    ++this->linebuffer.length;
}

int ChatScreen::handle_input(char *target, int max_len, int key)
{
    if (!(key & KEY_CODE_YES) && isprint(key))
    {
        add_char(key);
        return 0;
    }

    switch (key)
    {
    case ERR: /* no key pressed */
        break;
    case KEY_LEFT:
        if (this->linebuffer.cursor > 0)
        {
            this->linebuffer.cursor--;
        }
        break;
    case KEY_RIGHT:
        if (this->linebuffer.cursor < this->linebuffer.length)
        {
            this->linebuffer.cursor++;
        }
        break;
    case KEY_HOME:
        this->linebuffer.cursor = 0;
        break;
    case KEY_END:
        this->linebuffer.cursor = this->linebuffer.length;
        break;
    case '\t':
        add_char(buf, '\t');
        break;
    case KEY_BACKSPACE:
    case 127:
    case 8:
        if (this->linebuffer.cursor <= 0)
        {
            break;
        }
        this->linebuffer.cursor--;
        // Fall-through
    case KEY_DC:
        if (this->linebuffer.cursor < this->linebuffer.length)
        {
            memmove(
                &this->linebuffer.ln[this->linebuffer.cursor],
                &this->linebuffer.ln[this->linebuffer.cursor + 1],
                this->linebuffer.length - this->linebuffer.cursor - 1);
            this->linebuffer.length--;
        }
        break;
    case KEY_ENTER:
    case '\r':
    case '\n':
        return retrieve_content(buf, target, max_len);
    }
    return 0;
}

int ChatScreen::get_line_non_blocking(char *target, int max_len)
{
    while (1)
    {
        int key = getch();
        if (key == ERR)
        {
            // No more input
            return 0;
        }
        int n = handle_input(buf, target, max_len, key);
        if (n)
        {
            return n;
        }
    }
}

void ChatScreen::read()
{
    while (1)
    {
        char ln[1024];
        int len = get_line_non_blocking(&lnbuffer, ln, sizeof(ln));
        if (len > 0)
        {
            mvaddstr(7 + lines_read, 0, ln);
            lines_read++;
        }
        move(0, 0);
        render_line(&lnbuffer);
    }
}
